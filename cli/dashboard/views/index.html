<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sailing Dashboard</title>
  <script src="https://unpkg.com/htmx.org@2.0.4"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <style>
    /* === Reset & Base === */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    /* === Dark Theme === */
    [data-theme="dark"] {
      --bg-primary: #111827;
      --bg-secondary: #1F2937;
      --bg-card: #374151;
      --bg-hover: #4B5563;
      --ok: #10B981;
      --ok-bg: rgba(16, 185, 129, 0.15);
      --risk: #F59E0B;
      --risk-bg: rgba(245, 158, 11, 0.15);
      --blocked: #EF4444;
      --blocked-bg: rgba(239, 68, 68, 0.15);
      --accent: #3B82F6;
      --accent-light: #60A5FA;
      --text: #F9FAFB;
      --text-muted: #9CA3AF;
      --text-dim: #6B7280;
      --border: #374151;
    }

    /* === Light Theme === */
    [data-theme="light"] {
      --bg-primary: #F1F3F5;
      --bg-secondary: #FAFAFA;
      --bg-card: #E9ECEF;
      --bg-hover: #DEE2E6;
      --ok: #059669;
      --ok-bg: rgba(5, 150, 105, 0.15);
      --risk: #B45309;
      --risk-bg: rgba(180, 83, 9, 0.15);
      --blocked: #DC2626;
      --blocked-bg: rgba(220, 38, 38, 0.15);
      --accent: #1D4ED8;
      --accent-light: #2563EB;
      --text: #1F2937;
      --text-muted: #4B5563;
      --text-dim: #6B7280;
      --border: #D1D5DB;
    }

    :root {
      --radius: 6px;
      --radius-lg: 8px;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      font-size: 14px;
      line-height: 1.5;
      background: var(--bg-primary);
      color: var(--text);
      min-height: 100vh;
    }

    /* === Layout === */
    .app {
      display: grid;
      grid-template-columns: 280px 1fr;
      grid-template-rows: 48px 1fr;
      height: 100vh;
    }

    /* === Header === */
    .header {
      grid-column: 1 / -1;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 20px;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .logo {
      font-weight: 600;
      font-size: 15px;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .logo::before {
      content: "ðŸ´â€â˜ ï¸";
      font-size: 18px;
    }

    .project-info {
      color: var(--text-muted);
      font-weight: 500;
    }

    .version-badge {
      background: var(--bg-card);
      padding: 4px 10px;
      border-radius: var(--radius);
      font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
      font-size: 12px;
      color: var(--accent-light);
      font-weight: 500;
    }

    /* === Sidebar === */
    .sidebar {
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      overflow-y: auto;
      padding: 0;
    }

    .main {
      background: var(--bg-primary);
      overflow-y: auto;
      padding: 20px 24px;
    }

    /* === Native Treeview with details/summary === */
    .treeview {
      font-size: 13px;
      padding: 8px 0;
    }

    .treeview details {
      margin: 0;
    }

    .treeview summary {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      cursor: pointer;
      list-style: none;
      gap: 8px;
      border-radius: var(--radius);
      margin: 1px 4px;
      transition: background 0.1s;
    }

    .treeview summary::-webkit-details-marker { display: none; }

    .treeview summary:hover {
      background: var(--bg-hover);
    }

    .treeview summary::before {
      content: "â–¶";
      font-size: 8px;
      color: var(--text-dim);
      transition: transform 0.15s;
      width: 12px;
    }

    .treeview details[open] > summary::before {
      transform: rotate(90deg);
    }

    .treeview .node-icon {
      font-size: 14px;
      width: 18px;
      text-align: center;
    }

    .treeview .node-label {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      color: var(--text);
    }

    .treeview .node-badge {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .treeview .badge-ok { background: var(--ok-bg); color: var(--ok); }
    .treeview .badge-risk { background: var(--risk-bg); color: var(--risk); }
    .treeview .badge-blocked { background: var(--blocked-bg); color: var(--blocked); }
    .treeview .badge-draft { background: var(--bg-card); color: var(--text-dim); }
    .treeview .badge-wip { background: var(--accent); color: white; }

    /* Nested levels indentation */
    .treeview .level-1 { padding-left: 24px; }
    .treeview .level-2 { padding-left: 40px; }
    .treeview .level-3 { padding-left: 56px; }

    .treeview .level-1 .node-label,
    .treeview .level-2 .node-label {
      font-size: 12px;
      color: var(--text-muted);
    }

    /* Leaf nodes (no expand arrow) */
    .treeview .leaf {
      display: flex;
      align-items: center;
      padding: 5px 12px 5px 24px;
      gap: 8px;
      margin: 1px 4px;
      cursor: pointer;
      border-radius: var(--radius);
      transition: background 0.1s;
    }

    .treeview .leaf:hover {
      background: var(--bg-hover);
    }

    .treeview .leaf .node-icon {
      font-size: 12px;
      opacity: 0.7;
    }

    /* Header buttons */
    .header-btn {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 6px 10px;
      cursor: pointer;
      color: var(--text);
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: background 0.15s;
    }

    .header-btn:hover {
      background: var(--bg-hover);
    }

    /* === Status Badges (Feux tricolores) === */
    .status {
      font-size: 10px;
      font-weight: 600;
      padding: 3px 8px;
      border-radius: var(--radius);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    .status-draft { background: var(--bg-card); color: var(--text-muted); }
    .status-active, .status-in-progress, .status-wip { background: var(--accent); color: white; }
    .status-approved { background: var(--ok-bg); color: var(--ok); border: 1px solid var(--ok); }
    .status-review { background: var(--risk-bg); color: var(--risk); border: 1px solid var(--risk); }
    .status-done { background: var(--ok-bg); color: var(--ok); border: 1px solid var(--ok); }
    .status-blocked { background: var(--blocked-bg); color: var(--blocked); border: 1px solid var(--blocked); }
    .status-ready { background: var(--ok-bg); color: var(--ok); border: 1px solid var(--ok); }

    /* === Progress Bars === */
    .progress-bar {
      height: 4px;
      background: var(--bg-card);
      border-radius: 2px;
      overflow: hidden;
    }

    .progress-bar.progress-sm { height: 3px; }
    .progress-bar.progress-lg { height: 6px; border-radius: 3px; }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent) 0%, var(--accent-light) 100%);
      border-radius: inherit;
      transition: width 0.3s ease;
    }

    /* Progress color based on percentage */
    .progress-fill.progress-low { background: var(--blocked); }
    .progress-fill.progress-mid { background: var(--risk); }
    .progress-fill.progress-high { background: var(--ok); }

    .detail-progress {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
    }

    .detail-progress .progress-bar {
      flex: 1;
    }

    .progress-label {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
      min-width: 40px;
    }

    /* === KPI Cards === */
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin-bottom: 20px;
    }

    .kpi-card {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      padding: 14px 16px;
      border: 1px solid var(--border);
    }

    .kpi-label {
      font-size: 11px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 4px;
    }

    .kpi-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
      font-family: 'SF Mono', Consolas, monospace;
    }

    .kpi-value.ok { color: var(--ok); }
    .kpi-value.risk { color: var(--risk); }
    .kpi-value.blocked { color: var(--blocked); }

    /* === Detail View === */
    .detail-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .detail-header h2 {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      flex: 1;
    }

    /* === Epic Cards === */
    .epic-card {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      padding: 14px 16px;
      margin-bottom: 10px;
      border: 1px solid var(--border);
      border-left: 3px solid var(--accent);
    }

    .epic-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .epic-id {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 11px;
      color: var(--accent-light);
      font-weight: 500;
    }

    .epic-title {
      flex: 1;
      font-weight: 500;
      font-size: 13px;
    }

    .tasks-list {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    .task-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 5px 0;
      font-size: 12px;
    }

    .task-id {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 10px;
      color: var(--text-dim);
      min-width: 42px;
    }

    .task-title {
      flex: 1;
      color: var(--text-muted);
    }

    /* === Warnings Panel === */
    .warnings-panel {
      margin-top: 0;
    }

    .warning-badge {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--risk);
      padding: 10px 16px;
      font-size: 12px;
      font-weight: 500;
    }

    .blocker-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      font-size: 12px;
      border-left: 3px solid var(--blocked);
      background: var(--blocked-bg);
      margin: 2px 0;
    }

    .blocker-icon {
      font-size: 10px;
    }

    .blocker-id {
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 10px;
      color: var(--blocked);
      font-weight: 600;
    }

    .blocker-title {
      flex: 1;
      color: var(--text);
    }

    .blocker-reason {
      color: var(--text-muted);
      font-size: 11px;
    }

    .pending-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 8px 16px;
    }

    .pending-item {
      background: var(--risk-bg);
      color: var(--risk);
      padding: 3px 8px;
      border-radius: var(--radius);
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 11px;
      font-weight: 500;
    }

    /* === Versions === */
    .header-right {
      display: flex;
      gap: 16px;
    }

    .version-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
    }

    .version-name {
      color: var(--text-muted);
    }

    .version-number {
      font-family: 'SF Mono', Consolas, monospace;
      color: var(--text-dim);
    }

    .main-badge {
      color: var(--ok);
      font-size: 12px;
    }

    /* === Empty States === */
    .empty {
      color: var(--text-dim);
      padding: 12px 16px;
      font-size: 12px;
    }

    .empty.success {
      color: var(--ok);
      background: var(--ok-bg);
      border-radius: var(--radius);
      margin: 4px 8px;
    }

    /* === Loading === */
    .htmx-request {
      opacity: 0.5;
    }

    /* === Epics list === */
    .epics-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* === Tabs === */
    .tabs {
      margin-top: 16px;
    }

    .tab-buttons {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid var(--border);
      margin-bottom: 16px;
    }

    .tab-btn {
      background: transparent;
      border: none;
      padding: 8px 16px;
      font-size: 13px;
      color: var(--text-muted);
      cursor: pointer;
      border-bottom: 2px solid transparent;
      margin-bottom: -1px;
      transition: all 0.15s;
    }

    .tab-btn:hover {
      color: var(--text);
      background: var(--bg-hover);
    }

    .tab-btn.active {
      color: var(--accent-light);
      border-bottom-color: var(--accent);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .description-content {
      color: var(--text-muted);
      line-height: 1.7;
    }

    .description-content h2, .description-content h3, .description-content h4 {
      color: var(--text);
      margin-top: 16px;
      margin-bottom: 8px;
    }

    .description-content code {
      background: var(--bg-card);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 12px;
    }

    .description-content pre {
      background: var(--bg-card);
      padding: 12px;
      border-radius: var(--radius);
      overflow-x: auto;
    }

    .description-content ul, .description-content ol {
      padding-left: 20px;
      margin: 8px 0;
    }

    .description-content a {
      color: var(--accent-light);
    }

    /* Meta table */
    .meta-table {
      width: 100%;
      border-collapse: collapse;
    }

    .meta-table tr {
      border-bottom: 1px solid var(--border);
    }

    .meta-table td {
      padding: 8px 12px;
      vertical-align: top;
    }

    .meta-key {
      font-weight: 600;
      color: var(--text-muted);
      width: 150px;
      font-size: 12px;
    }

    .meta-value {
      color: var(--text);
    }

    .meta-value code {
      background: var(--bg-card);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 12px;
      white-space: pre-wrap;
      word-break: break-all;
    }

    /* Graph/Relations */
    .graph-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .graph-section h4 {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .graph-item {
      display: inline-block;
      padding: 6px 12px;
      margin: 4px 8px 4px 0;
      border-radius: var(--radius);
      font-size: 13px;
    }

    .graph-item.parent {
      background: var(--accent);
      background: rgba(59, 130, 246, 0.15);
      border: 1px solid var(--accent);
    }

    .graph-item.child {
      background: var(--ok-bg);
      border: 1px solid var(--ok);
    }

    .graph-item.blocker {
      background: var(--blocked-bg);
      border: 1px solid var(--blocked);
    }

    .graph-item.story {
      background: var(--risk-bg);
      border: 1px solid var(--risk);
    }

    .graph-item.milestone {
      background: var(--bg-card);
      border: 1px solid var(--border);
    }

    .entity-link {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      cursor: pointer;
    }

    .entity-link:hover {
      color: var(--accent-light);
      text-decoration: underline;
    }

    /* Settings page */
    .settings-section {
      margin-bottom: 24px;
    }

    .settings-section h4 {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .config-preview {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 12px;
      font-family: 'SF Mono', Consolas, monospace;
      font-size: 11px;
      color: var(--text-muted);
      overflow-x: auto;
      max-height: 400px;
      overflow-y: auto;
    }

    .badge-custom {
      display: inline-block;
      background: var(--risk-bg);
      color: var(--risk);
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 3px;
      margin-left: 6px;
      font-weight: 600;
      text-transform: uppercase;
    }

    /* DAG/Mermaid styling */
    .dag-container {
      background: var(--bg-secondary);
      border-radius: var(--radius-lg);
      padding: 16px;
      overflow: auto;
      max-height: calc(100vh - 250px);
    }

    .dag-container .mermaid {
      min-width: max-content;
      min-height: max-content;
    }

    .dag-container .mermaid svg {
      min-width: 600px;
      min-height: 400px;
    }

    .dag-legend {
      display: flex;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }

    .dag-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .dag-legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    .dag-legend-color.prd { background: #3B82F6; }
    .dag-legend-color.epic { background: #10B981; }
    .dag-legend-color.task { background: #6B7280; }
    .dag-legend-color.done { background: #059669; }
    .dag-legend-color.blocked { background: #EF4444; }
    .dag-legend-color.wip { background: #F59E0B; }

    .dag-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .dag-toggle input {
      cursor: pointer;
    }

    /* Gantt legend */
    .gantt-legend {
      display: flex;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .gantt-legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      color: var(--text-muted);
    }

    .gantt-legend-color {
      width: 12px;
      height: 12px;
      border-radius: 2px;
    }

    .gantt-legend-color.not-started { background: #64748B; }
    .gantt-legend-color.active { background: #FBBF24; }
    .gantt-legend-color.done { background: #059669; }
    .gantt-legend-color.crit { background: #EF4444; }

    /* Mermaid Gantt task styling - target all possible class patterns */
    .mermaid rect.task {
      fill: #4B5563 !important;
      stroke: #374151 !important;
    }
    /* Done tasks - green */
    .mermaid rect.task.done,
    .mermaid .done0, .mermaid .done1, .mermaid .done2, .mermaid .done3,
    .mermaid rect[class*="done"] {
      fill: #059669 !important;
      stroke: #047857 !important;
    }
    /* Active/In Progress tasks - blue */
    .mermaid rect.task.active,
    .mermaid .active0, .mermaid .active1, .mermaid .active2, .mermaid .active3,
    .mermaid rect[class*="active"]:not([class*="Crit"]) {
      fill: #3B82F6 !important;
      stroke: #1E40AF !important;
    }
    /* Critical path tasks - red */
    .mermaid rect.task.crit,
    .mermaid .crit0, .mermaid .crit1, .mermaid .crit2, .mermaid .crit3,
    .mermaid rect[class*="crit"]:not([class*="done"]):not([class*="active"]) {
      fill: #EF4444 !important;
      stroke: #DC2626 !important;
    }
    /* Active + Critical - orange */
    .mermaid .activeCrit0, .mermaid .activeCrit1, .mermaid .activeCrit2,
    .mermaid rect[class*="activeCrit"] {
      fill: #F97316 !important;
      stroke: #EA580C !important;
    }
    /* Done + Critical - teal with border */
    .mermaid .doneCrit0, .mermaid .doneCrit1, .mermaid .doneCrit2,
    .mermaid rect[class*="doneCrit"] {
      fill: #10B981 !important;
      stroke: #059669 !important;
      stroke-width: 2px !important;
    }
    /* Task text styling */
    .mermaid .taskText, .mermaid .taskTextOutsideRight, .mermaid .taskTextOutsideLeft {
      fill: var(--text) !important;
      font-size: 13px !important;
    }
    /* Gantt axis/date labels */
    .mermaid .tick text, .mermaid .grid text, .mermaid text.titleText {
      fill: var(--text) !important;
    }
    .mermaid .sectionTitle, .mermaid .sectionTitle0, .mermaid .sectionTitle1 {
      fill: var(--text-muted) !important;
    }
    /* Light theme: force ALL Gantt/Mermaid text to be dark */
    [data-theme="light"] .mermaid text {
      fill: #111827 !important;
    }
    [data-theme="light"] .mermaid text[class*="Text"],
    [data-theme="light"] .mermaid text[class*="text"],
    [data-theme="light"] .mermaid text[class*="Title"],
    [data-theme="light"] .mermaid text[class*="title"] {
      fill: #000000 !important;
    }
    [data-theme="light"] .mermaid text[class*="section"] {
      fill: #374151 !important;
      font-weight: 600 !important;
    }

    /* Gantt horizontal grid lines */
    .mermaid svg .grid .tick line {
      stroke: var(--border);
      stroke-opacity: 0.3;
    }
    .mermaid svg .grid .tick:not(:first-of-type) line[x1="0"] {
      stroke: var(--border);
      stroke-opacity: 0.5;
    }
    /* Add subtle row separators for Gantt tasks */
    .dag-container .mermaid svg g.section rect,
    .dag-container .mermaid svg g rect.task {
      stroke: var(--border);
      stroke-width: 0.5;
      stroke-opacity: 0.3;
    }

    /* === Custom Sailing Gantt Styling (Material UI) === */
    .gantt-container {
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 16px;
      overflow: auto;
      max-height: calc(100vh - 280px);
    }
    .gantt-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text);
      margin-bottom: 8px;
      letter-spacing: 0.01em;
    }
    .gantt-controls {
      display: flex;
      gap: 2px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }
    .gantt-zoom {
      padding: 5px 14px;
      font-size: 11px;
      font-weight: 500;
      background: transparent;
      color: var(--text-muted);
      border: none;
      border-radius: 16px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .gantt-zoom:hover {
      background: var(--bg-hover);
      color: var(--text);
    }
    .gantt-zoom.active {
      background: var(--accent);
      color: white;
    }
    .sailing-gantt-target {
      min-height: 200px;
      overflow-x: auto;
    }
    .sailing-gantt-target svg {
      display: block;
    }
    .sailing-gantt-target .gantt-grid-line {
      stroke: var(--border);
      stroke-opacity: 0.15;
    }
    .sailing-gantt-target .gantt-axis-text {
      fill: var(--text-dim);
      font-size: 14px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: 500;
      letter-spacing: 0.02em;
    }
    .sailing-gantt-target .gantt-bar {
      cursor: pointer;
    }
    .sailing-gantt-target .gantt-bar:hover .gantt-bar-fill {
      filter: brightness(1.1);
    }
    .sailing-gantt-target .gantt-bar:hover .gantt-bar-fill.critical {
      filter: brightness(1.1) drop-shadow(0 0 2px #7F1D1D) drop-shadow(0 0 3px #991B1B);
    }
    /* Custom tooltip */
    .gantt-tooltip {
      position: fixed;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      pointer-events: none;
      z-index: 1000;
      max-width: 280px;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .gantt-tooltip.visible {
      opacity: 1;
    }
    .gantt-tooltip-title {
      font-weight: 600;
      color: var(--text);
      margin-bottom: 4px;
    }
    .gantt-tooltip-row {
      display: flex;
      gap: 8px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    .gantt-tooltip-label {
      color: var(--text-muted);
    }
    .gantt-tooltip-value {
      color: var(--text);
    }
    .gantt-tooltip-critical {
      color: #F87171;
      font-weight: 500;
      margin-top: 4px;
    }
    .sailing-gantt-target .gantt-bar-bg {
      fill: transparent;
    }
    .sailing-gantt-target .gantt-bar-fill {
      fill: #64748B;
      transition: filter 0.15s;
    }
    .sailing-gantt-target .gantt-bar-fill.done {
      fill: #10B981;
    }
    .sailing-gantt-target .gantt-bar-fill.active {
      fill: #FBBF24;
    }
    .sailing-gantt-target .gantt-bar-fill.critical {
      fill: #F87171;
      stroke: #B91C1C;
      stroke-width: 1;
      filter: drop-shadow(0 0 2px #7F1D1D) drop-shadow(0 0 3px #991B1B);
    }
    .sailing-gantt-target .gantt-bar-fill.done.critical {
      fill: #10B981;
      stroke: #B91C1C;
      stroke-width: 1;
      filter: drop-shadow(0 0 2px #7F1D1D) drop-shadow(0 0 3px #991B1B);
    }
    .sailing-gantt-target .gantt-bar-fill.active.critical {
      fill: #FB923C;
      stroke: #B91C1C;
      stroke-width: 1;
      filter: drop-shadow(0 0 2px #7F1D1D) drop-shadow(0 0 3px #991B1B);
    }
    .sailing-gantt-target .gantt-bar-label {
      fill: var(--text-muted);
      font-size: 16px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: 400;
      pointer-events: none;
    }
    .sailing-gantt-target .gantt-dep-arrow {
      fill: none;
      stroke: #6B7280;
      stroke-width: 1;
    }
    .sailing-gantt-target .gantt-dep-arrow.critical {
      stroke: #B91C1C;
      stroke-width: 1;
    }
    .sailing-gantt-target .gantt-now-line {
      stroke: #00D4FF;
      stroke-width: 2;
      stroke-dasharray: 4 2;
      filter: drop-shadow(0 0 3px #00D4FF);
    }
    .sailing-gantt-target .gantt-critical-line {
      stroke: #F59E0B;
      stroke-width: 2;
      stroke-dasharray: 4 2;
      filter: drop-shadow(0 0 3px #F59E0B);
    }
    .sailing-gantt-target .gantt-bar-progress {
      fill: #10B981;
      opacity: 0.6;
    }
    .sailing-gantt-target .gantt-epic-header {
      fill: var(--text);
      font-size: 14px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .sailing-gantt-target .gantt-epic-bg-odd {
      fill: var(--bg-card);
      opacity: 0.4;
    }
    .sailing-gantt-target .gantt-epic-bg-even {
      fill: var(--bg-secondary);
      opacity: 0.6;
    }
    .sailing-gantt-target .gantt-row-odd {
      fill: transparent;
    }
    .sailing-gantt-target .gantt-row-even {
      fill: var(--bg-hover);
      opacity: 0.15;
    }
    [data-theme="light"] .sailing-gantt-target .gantt-bar-label {
      fill: #374151;
    }

    /* === Scrollbar styling === */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-primary);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--bg-card);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--bg-hover);
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <div class="header-left">
        <span class="logo" hx-get="/api/welcome" hx-target="#detail" hx-swap="innerHTML" style="cursor: pointer;" title="Home">Sailing</span>
        <span class="project-info">{{projectName}}</span>
        <span class="version-badge">v{{mainVersion}}</span>
      </div>
      <div class="header-right">
        <button class="header-btn" hx-get="/api/settings" hx-target="#detail" hx-swap="innerHTML" title="Settings">
          âš™
        </button>
        <button class="header-btn" onclick="toggleTheme()" title="Toggle theme">
          <span id="theme-icon">â˜€</span>
        </button>
      </div>
    </header>

    <aside class="sidebar">
      <nav class="treeview" id="tree" hx-get="/api/tree" hx-trigger="load" hx-swap="innerHTML">
        <div style="padding: 12px; color: var(--text-dim);">Loading...</div>
      </nav>
    </aside>

    <main class="main">
      <div id="detail" hx-get="/api/welcome" hx-trigger="load" hx-swap="innerHTML">
        <div class="empty">Loading...</div>
      </div>
    </main>
  </div>

  <script>
    // Theme toggle
    function toggleTheme() {
      const html = document.documentElement;
      const current = html.getAttribute('data-theme');
      const next = current === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      document.getElementById('theme-icon').textContent = next === 'dark' ? 'â˜€' : 'â˜¾';
      localStorage.setItem('sailing-theme', next);
      // Re-initialize Mermaid with new theme
      initMermaid();
    }

    // Load saved theme
    const savedTheme = localStorage.getItem('sailing-theme');
    if (savedTheme) {
      document.documentElement.setAttribute('data-theme', savedTheme);
      document.getElementById('theme-icon').textContent = savedTheme === 'dark' ? 'â˜€' : 'â˜¾';
    }

    // Auto-refresh every 30s
    setInterval(() => {
      htmx.trigger('#tree', 'load');
    }, 30000);

    // Track current tab preference
    window._currentTab = localStorage.getItem('sailing-current-tab') || 'overview';

    // Tab switching
    function switchTab(btn, tabId) {
      const tabs = btn.closest('.tabs');
      tabs.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      tabs.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      tabs.querySelector('#' + tabId).classList.add('active');
      // Save tab preference
      window._currentTab = tabId;
      localStorage.setItem('sailing-current-tab', tabId);
      // Render mermaid if switching to schema tab
      if (tabId === 'schema') {
        renderMermaid();
      }
      // Render Frappe Gantt if switching to gantt tab
      if (tabId === 'gantt') {
        renderSailingGantt();
      }
    }

    // Restore tab after navigation
    function restoreTab() {
      const tabs = document.querySelector('#detail .tabs');
      if (!tabs) return;
      const preferredTab = window._currentTab;
      const targetBtn = tabs.querySelector(`.tab-btn[onclick*="'${preferredTab}'"]`);
      if (targetBtn) {
        switchTab(targetBtn, preferredTab);
      }
    }

    // Mermaid initialization based on theme
    function initMermaid() {
      const isLight = document.documentElement.getAttribute('data-theme') === 'light';
      mermaid.initialize({
        startOnLoad: false,
        securityLevel: 'loose',
        theme: isLight ? 'default' : 'dark',
        themeVariables: isLight ? {
          primaryColor: '#3B82F6',
          primaryTextColor: '#111827',
          primaryBorderColor: '#D1D5DB',
          lineColor: '#6B7280',
          secondaryColor: '#10B981',
          tertiaryColor: '#F3F4F6',
          taskTextColor: '#111827',
          taskTextOutsideColor: '#111827',
          taskTextClickableColor: '#111827',
          sectionBkgColor: '#F9FAFB',
          gridColor: '#E5E7EB',
          doneTaskBorderColor: '#047857',
          doneTaskBkgColor: '#059669',
          critBorderColor: '#DC2626',
          critBkgColor: '#EF4444',
          activeTaskBorderColor: '#1E40AF',
          activeTaskBkgColor: '#3B82F6'
        } : {
          primaryColor: '#3B82F6',
          primaryTextColor: '#F9FAFB',
          primaryBorderColor: '#374151',
          lineColor: '#6B7280',
          secondaryColor: '#10B981',
          tertiaryColor: '#1F2937'
        },
        flowchart: {
          curve: 'basis',
          padding: 20,
          nodeSpacing: 50,
          rankSpacing: 60,
          useMaxWidth: false
        },
        gantt: {
          useMaxWidth: false,
          barHeight: 28,
          barGap: 8,
          topPadding: 50,
          leftPadding: 180,
          gridLineStartPadding: 35,
          fontSize: 13,
          sectionFontSize: 14
        }
      });
    }
    initMermaid();

    // Render mermaid diagrams
    async function renderMermaid() {
      const elements = document.querySelectorAll('.mermaid:not([data-processed])');
      for (const el of elements) {
        el.setAttribute('data-processed', 'true');
        const code = el.textContent;
        try {
          const { svg } = await mermaid.render('mermaid-' + Date.now(), code);
          el.innerHTML = svg;
          // Apply tooltips from window._dagTooltips
          applyDagTooltips(el);
        } catch (e) {
          console.error('Mermaid error:', e);
          el.innerHTML = '<div style="color: var(--blocked);">Error rendering diagram</div>';
        }
      }
    }

    // Render custom Sailing Gantt charts
    function renderSailingGantt() {
      const containers = document.querySelectorAll('.sailing-gantt-target:not([data-processed])');
      containers.forEach(container => {
        container.setAttribute('data-processed', 'true');
        const dataScript = container.parentElement.querySelector('script.gantt-data');
        if (!dataScript) return;

        try {
          const data = JSON.parse(dataScript.textContent);
          const { tasks, totalHours, d0, simple, durationHours, criticalTimespanHours } = data;
          const startDate = d0 ? new Date(d0) : new Date();

          if (!tasks || tasks.length === 0) {
            container.innerHTML = '<div style="color: var(--text-dim); padding: 20px;">No tasks</div>';
            return;
          }

          // Store data for zoom changes and tooltip
          container._ganttData = data;
          container._zoomMode = simple ? 'week' : 'day'; // default: week for simple, day for full
          container._simpleMode = simple || false;
          container._startDate = startDate;

          renderGanttSVG(container, tasks, totalHours, container._zoomMode, startDate, simple, criticalTimespanHours);

          // Setup zoom controls
          const controls = container.parentElement.querySelector('.gantt-controls');
          if (controls) {
            controls.querySelectorAll('.gantt-zoom').forEach(btn => {
              btn.addEventListener('click', () => {
                controls.querySelectorAll('.gantt-zoom').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                const zoom = btn.dataset.zoom;
                container._zoomMode = zoom;
                renderGanttSVG(container, tasks, totalHours, zoom, startDate, simple, criticalTimespanHours);
              });
            });
          }
        } catch (e) {
          console.error('Sailing Gantt error:', e);
          container.innerHTML = '<div style="color: var(--blocked);">Error rendering Gantt chart: ' + e.message + '</div>';
        }
      });
    }

    // Render the SVG Gantt chart
    function renderGanttSVG(container, tasks, totalHours, zoomMode, startDate, simpleMode = false, criticalTimespanHours = null) {
      // Format date helper
      const formatDate = (date, withYear = false) => {
        const d = date.getDate();
        const m = date.toLocaleString('default', { month: 'short' });
        if (withYear) {
          const y = date.getFullYear();
          return `${d} ${m} ${y}`;
        }
        return `${d} ${m}`;
      };

      // Configuration based on zoom mode with real dates
      const config = {
        hour: {
          unitWidth: 40,
          labelInterval: 4,
          labelFormat: h => {
            const d = new Date(startDate);
            d.setHours(d.getHours() + h);
            return `${d.getHours()}h`;
          }
        },
        day: {
          unitWidth: 25,
          labelInterval: 24,
          labelFormat: h => {
            const d = new Date(startDate);
            d.setHours(d.getHours() + h);
            return formatDate(d);
          }
        },
        week: {
          unitWidth: 6,
          labelInterval: 40,
          labelFormat: h => {
            const d = new Date(startDate);
            d.setHours(d.getHours() + h);
            return formatDate(d);
          }
        },
        month: {
          unitWidth: 1.5,
          labelInterval: 168, // ~1 week in hours
          labelFormat: h => {
            const d = new Date(startDate);
            d.setHours(d.getHours() + h);
            return formatDate(d);
          }
        }
      }[zoomMode];

      const rowHeight = 42;
      const epicHeaderHeight = 26;
      const labelWidth = 380;
      const headerHeight = 42;
      const padding = { top: 12, right: 20, bottom: 12, left: 10 };
      const barHeight = 26;

      // In simple mode, don't group by epic
      let epicGroups = new Map();
      let hasEpics = false;
      let totalRows = tasks.length;

      if (!simpleMode) {
        // Group tasks by epic
        tasks.forEach(task => {
          const epicId = task.epicId || '_none';
          if (!epicGroups.has(epicId)) {
            epicGroups.set(epicId, { id: epicId, title: task.epicTitle || 'Tasks', tasks: [] });
          }
          epicGroups.get(epicId).tasks.push(task);
        });

        // Calculate total rows (tasks + epic headers)
        totalRows = 0;
        hasEpics = epicGroups.size > 1 || (epicGroups.size === 1 && !epicGroups.has('_none'));
        if (hasEpics) {
          epicGroups.forEach(group => {
            totalRows += 1; // Epic header
            totalRows += group.tasks.length;
          });
        } else {
          totalRows = tasks.length;
        }
      }

      // Ensure minimum total hours for display
      const displayHours = Math.max(totalHours, 8);

      // Use fixed unitWidth from config (minimum size, never compress below this)
      const unitWidth = config.unitWidth;

      // Calculate required chart width based on content (overflow if needed)
      const containerWidth = container.offsetWidth || 800;
      const requiredWidth = labelWidth + (displayHours * unitWidth) + padding.left + padding.right;
      const chartWidth = Math.max(requiredWidth, containerWidth);

      const chartHeight = headerHeight + (totalRows * rowHeight) + padding.top + padding.bottom;

      // Build task position map for dependency arrows
      const taskPositions = new Map();

      // Create SVG
      let svg = `<svg width="${chartWidth}" height="${chartHeight}" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <marker id="arrowhead" markerWidth="6" markerHeight="5" refX="6" refY="2.5" orient="auto">
            <polygon points="0 0, 6 2.5, 0 5" fill="var(--border)"/>
          </marker>
          <marker id="arrowhead-crit" markerWidth="6" markerHeight="5" refX="6" refY="2.5" orient="auto">
            <polygon points="0 0, 6 2.5, 0 5" fill="#F87171"/>
          </marker>
          <marker id="arrowhead-down" markerWidth="4" markerHeight="4" refX="2" refY="4" orient="0">
            <polygon points="0 0, 4 0, 2 4" fill="#6B7280"/>
          </marker>
          <marker id="arrowhead-down-crit" markerWidth="4" markerHeight="4" refX="2" refY="4" orient="0">
            <polygon points="0 0, 4 0, 2 4" fill="#EF4444"/>
          </marker>
          <marker id="arrowhead-critical-span" markerWidth="8" markerHeight="6" refX="8" refY="3" orient="auto">
            <polygon points="0 0, 8 3, 0 6" fill="#EF4444"/>
          </marker>
        </defs>`;

      // Background
      svg += `<rect width="${chartWidth}" height="${chartHeight}" fill="var(--bg-secondary)"/>`;

      // Grid lines and time axis
      const gridStartX = labelWidth + padding.left;

      // T0 date in the header above label column (with year)
      svg += `<text x="${padding.left + 10}" y="${headerHeight - 6}" class="gantt-axis-text" style="font-weight:600">${formatDate(startDate, true)}</text>`;

      for (let h = 0; h <= displayHours; h += config.labelInterval) {
        const x = gridStartX + (h * unitWidth);
        svg += `<line x1="${x}" y1="${headerHeight}" x2="${x}" y2="${chartHeight - padding.bottom}" class="gantt-grid-line"/>`;
        if (h > 0) {
          svg += `<text x="${x}" y="${headerHeight - 6}" class="gantt-axis-text" text-anchor="middle">${config.labelFormat(h)}</text>`;
        }
      }

      // Critical timespan arrow (horizontal arrow in header showing minimum theoretical time)
      // Arrow starts at the first task position
      if (criticalTimespanHours && criticalTimespanHours > 0 && !simpleMode && tasks.length > 0) {
        // Find earliest start hour among all tasks
        const earliestStartHour = Math.min(...tasks.map(t => t.startHour));
        const arrowY = 12;
        const arrowStartX = gridStartX + (earliestStartHour * unitWidth);
        const arrowEndX = arrowStartX + (criticalTimespanHours * unitWidth);
        const roundedHours = Math.round(criticalTimespanHours * 10) / 10; // Round to 1 decimal
        svg += `<line x1="${arrowStartX}" y1="${arrowY}" x2="${arrowEndX - 8}" y2="${arrowY}"
                  stroke="#EF4444" stroke-width="2" marker-end="url(#arrowhead-critical-span)"/>`;
        svg += `<text x="${arrowEndX + 4}" y="${arrowY + 4}" class="gantt-axis-text" style="fill:#EF4444;font-size:10px;">${roundedHours}h critical</text>`;
      }

      // First pass: calculate all task positions
      let currentRow = 0;
      const taskBars = [];  // Store bar data for later rendering

      const calculateTaskPosition = (task, rowIndex, epicIdx, taskIdx) => {
        const y = headerHeight + (rowIndex * rowHeight);
        const barY = y + (rowHeight - barHeight) / 2;
        const barX = gridStartX + (task.startHour * unitWidth);
        const maxBarX = chartWidth - padding.right;
        // Clip bar width to not exceed chart boundaries
        const rawBarW = Math.max((task.endHour - task.startHour) * unitWidth, 3);
        const barW = Math.min(rawBarW, maxBarX - barX);

        // Store position for dependency arrows
        taskPositions.set(task.id, { x: barX, y: barY + barHeight / 2, topY: barY, bottomY: barY + barHeight, width: barW, endX: barX + barW });

        // Store bar data for later rendering
        taskBars.push({ task, y, barY, barX, barW, epicIdx, taskIdx });
      };

      // Calculate positions (grouped by epic or flat)
      if (hasEpics) {
        let epicIdx = 0;
        epicGroups.forEach(group => {
          currentRow++; // Epic header
          group.tasks.forEach((task, taskIdx) => {
            calculateTaskPosition(task, currentRow, epicIdx, taskIdx);
            currentRow++;
          });
          epicIdx++;
        });
      } else {
        tasks.forEach((task, i) => {
          calculateTaskPosition(task, i, 0, i);
        });
      }

      // PASS 1: Render row backgrounds only
      currentRow = 0;
      if (hasEpics) {
        let epicIdx = 0;
        epicGroups.forEach(group => {
          // Epic header row background
          const headerY = headerHeight + (currentRow * rowHeight);
          const epicBgClass = epicIdx % 2 === 0 ? 'gantt-epic-bg-odd' : 'gantt-epic-bg-even';
          svg += `<rect x="0" y="${headerY}" width="${chartWidth}" height="${rowHeight}" class="${epicBgClass}"/>`;
          svg += `<text x="${padding.left + 6}" y="${headerY + rowHeight/2 + 4}" class="gantt-epic-header">${escapeHtml(group.id)} ${escapeHtml(group.title)}</text>`;
          currentRow++;

          // Task row backgrounds
          group.tasks.forEach(() => {
            const y = headerHeight + (currentRow * rowHeight);
            const epicOddEven = epicIdx % 2 === 0 ? 'odd' : 'even';
            const rowClass = `gantt-row-${epicOddEven}`;
            svg += `<rect x="0" y="${y}" width="${chartWidth}" height="${rowHeight}" class="${rowClass}"/>`;
            currentRow++;
          });
          epicIdx++;
        });
      } else {
        tasks.forEach((task, i) => {
          const y = headerHeight + (i * rowHeight);
          const rowClass = `gantt-row-${i % 2 === 0 ? 'odd' : 'even'}`;
          svg += `<rect x="0" y="${y}" width="${chartWidth}" height="${rowHeight}" class="${rowClass}"/>`;
        });
      }

      // PASS 2: Current time line (electric blue, behind tasks)
      const now = new Date();
      const hoursSinceT0 = (now - startDate) / (1000 * 60 * 60);
      if (hoursSinceT0 >= 0 && hoursSinceT0 <= displayHours) {
        const nowX = gridStartX + (hoursSinceT0 * unitWidth);
        svg += `<line x1="${nowX}" y1="${headerHeight}" x2="${nowX}" y2="${chartHeight - padding.bottom}" class="gantt-now-line"/>`;
      }

      // PASS 2b: Critical span end line (yellow dashed, vertical line at end of critical timespan)
      if (criticalTimespanHours && criticalTimespanHours > 0 && !simpleMode && tasks.length > 0) {
        const earliestStartHour = Math.min(...tasks.map(t => t.startHour));
        const criticalEndHour = earliestStartHour + criticalTimespanHours;
        if (criticalEndHour >= 0 && criticalEndHour <= displayHours) {
          const criticalX = gridStartX + (criticalEndHour * unitWidth);
          svg += `<line x1="${criticalX}" y1="${headerHeight}" x2="${criticalX}" y2="${chartHeight - padding.bottom}" class="gantt-critical-line"/>`;
        }
      }

      // PASS 3: Draw dependency arrows (behind task bars) - skip in simple mode
      if (!simpleMode) {
        svg += `<g class="gantt-arrows">`;
        tasks.forEach(task => {
          if (!task.dependencies || task.dependencies.length === 0) return;
          const toPos = taskPositions.get(task.id);
          if (!toPos) return;

          task.dependencies.forEach(depId => {
            const fromPos = taskPositions.get(depId);
            if (!fromPos) return;

            const fromX = fromPos.endX;
            const fromY = fromPos.y;
            const dropX = toPos.x + 4;
            const toY = toPos.topY + 2;

          const depTask = tasks.find(t => t.id === depId);
          const isCriticalDep = task.isCritical && depTask && depTask.isCritical;
          const arrowClass = isCriticalDep ? 'gantt-dep-arrow critical' : 'gantt-dep-arrow';
          const markerIdDown = isCriticalDep ? 'arrowhead-down-crit' : 'arrowhead-down';

          const r = 4;
          svg += `<path d="M${fromX},${fromY} H${dropX - r} Q${dropX},${fromY} ${dropX},${fromY + r} V${toY}" class="${arrowClass}" marker-end="url(#${markerIdDown})"/>`;
          });
        });
        svg += `</g>`;
      }

      // PASS 4: Render labels (behind task bars)
      currentRow = 0;
      if (hasEpics) {
        let epicIdx = 0;
        epicGroups.forEach(group => {
          currentRow++; // Skip epic header row
          group.tasks.forEach((task) => {
            const y = headerHeight + (currentRow * rowHeight);
            svg += `<text x="${padding.left + 10}" y="${y + rowHeight/2 + 5}" class="gantt-bar-label">${escapeHtml(task.name)}</text>`;
            currentRow++;
          });
          epicIdx++;
        });
      } else {
        tasks.forEach((task, i) => {
          const y = headerHeight + (i * rowHeight);
          svg += `<text x="${padding.left + 10}" y="${y + rowHeight/2 + 5}" class="gantt-bar-label">${escapeHtml(task.name)}</text>`;
        });
      }

      // PASS 5: Render task bars (on top)
      currentRow = 0;
      if (hasEpics) {
        let epicIdx = 0;
        epicGroups.forEach(group => {
          currentRow++; // Skip epic header row

          group.tasks.forEach((task, taskIdx) => {
            const y = headerHeight + (currentRow * rowHeight);
            const barY = y + (rowHeight - barHeight) / 2;
            const barX = gridStartX + (task.startHour * unitWidth);
            const barW = Math.max((task.endHour - task.startHour) * unitWidth, 3);

            const isInProgress = task.status === 'In Progress' || task.status === 'WIP';
            const isDone = task.status === 'Done' || task.status === 'Auto-Done';
            const statusClass = isDone ? 'done' : isInProgress ? 'active' : '';
            const critClass = task.isCritical ? 'critical' : '';
            const classes = [statusClass, critClass].filter(c => c).join(' ');

            // Check if timespan exceeds duration (for stretch visualization)
            const actualTimespan = task.endHour - task.startHour;
            const hasStretch = task.durationHours && actualTimespan > task.durationHours + 0.01; // small epsilon for float comparison

            // For Done tasks, ensure minimum bar width is the duration
            const effectiveBarW = (isDone && task.durationHours && actualTimespan < task.durationHours)
              ? Math.max(task.durationHours * unitWidth, 3)
              : barW;

            svg += `<g class="gantt-bar" data-task-id="${task.id}" data-name="${escapeHtml(task.name)}" data-epic="${escapeHtml(task.epicTitle || '')}" data-start="${task.startHour}" data-end="${task.endHour}" data-duration="${task.durationHours}" data-status="${task.status}" data-critical="${task.isCritical ? '1' : ''}" data-blocked-by="${(task.dependencies || []).join(',')}" data-blocks="${(task.blocks || []).join(',')}" onclick="htmx.ajax('GET', '/api/task/${task.id}', '#detail')">`;

            // For in-progress tasks: stretch on left, duration on right
            // For done tasks with stretch: duration on left, stretch on right
            if (isInProgress && hasStretch) {
              const durationW = Math.max(task.durationHours * unitWidth, 3);
              const stretchW = barW - durationW;
              const clipId = `clip-inprogress-${task.id.replace(/[^a-zA-Z0-9]/g, '_')}`;

              svg += `<defs><clipPath id="${clipId}"><rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3"/></clipPath></defs>`;
              if (task.isCritical) {
                svg += `<rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3" class="gantt-bar-fill critical" style="fill:none;"/>`;
              }
              svg += `<g clip-path="url(#${clipId})">`;
              // Stretch part on LEFT
              if (stretchW > 0) {
                svg += `<rect x="${barX}" y="${barY}" width="${stretchW}" height="${barHeight}" style="fill:rgba(251,191,36,0.15);"/>`;
                svg += `<rect x="${barX + 2}" y="${barY + 2}" width="${stretchW - 2}" height="${barHeight - 4}" style="fill:none;stroke:#FBBF24;stroke-width:1;stroke-dasharray:3 2;"/>`;
              }
              // Duration part on RIGHT
              const fillX = barX + stretchW;
              svg += `<rect x="${fillX}" y="${barY}" width="${durationW}" height="${barHeight}" class="gantt-bar-fill active"/>`;
              svg += `</g>`;
            } else if (isDone && hasStretch) {
              const durationW = Math.max(task.durationHours * unitWidth, 3);
              const stretchW = barW - durationW;
              const clipId = `clip-done-${task.id.replace(/[^a-zA-Z0-9]/g, '_')}`;

              svg += `<defs><clipPath id="${clipId}"><rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3"/></clipPath></defs>`;
              if (task.isCritical) {
                svg += `<rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3" class="gantt-bar-fill critical" style="fill:none;"/>`;
              }
              svg += `<g clip-path="url(#${clipId})">`;
              // Duration part on LEFT
              svg += `<rect x="${barX}" y="${barY}" width="${durationW}" height="${barHeight}" class="gantt-bar-fill done"/>`;
              // Stretch part on RIGHT
              if (stretchW > 0) {
                const stretchX = barX + durationW;
                svg += `<rect x="${stretchX}" y="${barY}" width="${stretchW}" height="${barHeight}" style="fill:rgba(34,197,94,0.15);"/>`;
                svg += `<rect x="${stretchX}" y="${barY + 2}" width="${stretchW - 2}" height="${barHeight - 4}" style="fill:none;stroke:#22C55E;stroke-width:1;stroke-dasharray:3 2;"/>`;
              }
              svg += `</g>`;
            } else {
              svg += `<rect x="${barX}" y="${barY}" width="${effectiveBarW}" height="${barHeight}" rx="3" class="gantt-bar-fill ${classes}"/>`;
            }
            svg += `</g>`;
            currentRow++;
          });
          epicIdx++;
        });
      } else {
        tasks.forEach((task, i) => {
          const y = headerHeight + (i * rowHeight);
          const barY = y + (rowHeight - barHeight) / 2;
          const barX = gridStartX + (task.startHour * unitWidth);
          const barW = Math.max((task.endHour - task.startHour) * unitWidth, 3);

          const isInProgress = task.status === 'In Progress' || task.status === 'WIP';
          const isDone = task.status === 'Done' || task.status === 'Auto-Done';
          const statusClass = isDone ? 'done' : isInProgress ? 'active' : '';
          const critClass = !simpleMode && task.isCritical ? 'critical' : '';
          const classes = [statusClass, critClass].filter(c => c).join(' ');

          // Check if timespan exceeds duration (for stretch visualization)
          const actualTimespan = task.endHour - task.startHour;
          const hasStretch = task.durationHours && actualTimespan > task.durationHours + 0.01; // small epsilon for float comparison

          // For Done tasks, ensure minimum bar width is the duration
          const effectiveBarW = (isDone && task.durationHours && actualTimespan < task.durationHours)
            ? Math.max(task.durationHours * unitWidth, 3)
            : barW;

          // Different onclick for simple mode (PRD) vs normal mode (Task)
          const apiPath = simpleMode ? `/api/prd/${task.id}` : `/api/task/${task.id}`;
          svg += `<g class="gantt-bar" data-task-id="${task.id}" data-name="${escapeHtml(task.name)}" data-epic="${escapeHtml(task.epicTitle || '')}" data-start="${task.startHour}" data-end="${task.endHour}" data-duration="${task.durationHours}" data-status="${task.status}" data-critical="${!simpleMode && task.isCritical ? '1' : ''}" data-blocked-by="${(task.dependencies || []).join(',')}" data-blocks="${(task.blocks || []).join(',')}" data-progress="${task.progress || ''}" onclick="htmx.ajax('GET', '${apiPath}', '#detail')">`;

          // For in-progress tasks: stretch on left, duration on right
          // For done tasks with stretch: duration on left, stretch on right
          if (!simpleMode && isInProgress && hasStretch) {
            const durationW = Math.max(task.durationHours * unitWidth, 3);
            const stretchW = barW - durationW;
            const clipId = `clip-inprogress-${task.id.replace(/[^a-zA-Z0-9]/g, '_')}_${i}`;

            svg += `<defs><clipPath id="${clipId}"><rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3"/></clipPath></defs>`;
            if (task.isCritical) {
              svg += `<rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3" class="gantt-bar-fill critical" style="fill:none;"/>`;
            }
            svg += `<g clip-path="url(#${clipId})">`;
            // Stretch part on LEFT
            if (stretchW > 0) {
              svg += `<rect x="${barX}" y="${barY}" width="${stretchW}" height="${barHeight}" style="fill:rgba(251,191,36,0.15);"/>`;
              svg += `<rect x="${barX + 2}" y="${barY + 2}" width="${stretchW - 2}" height="${barHeight - 4}" style="fill:none;stroke:#FBBF24;stroke-width:1;stroke-dasharray:3 2;"/>`;
            }
            // Duration part on RIGHT
            const fillX = barX + stretchW;
            svg += `<rect x="${fillX}" y="${barY}" width="${durationW}" height="${barHeight}" class="gantt-bar-fill active"/>`;
            svg += `</g>`;
          } else if (!simpleMode && isDone && hasStretch) {
            const durationW = Math.max(task.durationHours * unitWidth, 3);
            const stretchW = barW - durationW;
            const clipId = `clip-done-${task.id.replace(/[^a-zA-Z0-9]/g, '_')}_${i}`;

            svg += `<defs><clipPath id="${clipId}"><rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3"/></clipPath></defs>`;
            if (task.isCritical) {
              svg += `<rect x="${barX}" y="${barY}" width="${barW}" height="${barHeight}" rx="3" class="gantt-bar-fill critical" style="fill:none;"/>`;
            }
            svg += `<g clip-path="url(#${clipId})">`;
            // Duration part on LEFT
            svg += `<rect x="${barX}" y="${barY}" width="${durationW}" height="${barHeight}" class="gantt-bar-fill done"/>`;
            // Stretch part on RIGHT
            if (stretchW > 0) {
              const stretchX = barX + durationW;
              svg += `<rect x="${stretchX}" y="${barY}" width="${stretchW}" height="${barHeight}" style="fill:rgba(34,197,94,0.15);"/>`;
              svg += `<rect x="${stretchX}" y="${barY + 2}" width="${stretchW - 2}" height="${barHeight - 4}" style="fill:none;stroke:#22C55E;stroke-width:1;stroke-dasharray:3 2;"/>`;
            }
            svg += `</g>`;
          } else {
            svg += `<rect x="${barX}" y="${barY}" width="${effectiveBarW}" height="${barHeight}" rx="3" class="gantt-bar-fill ${classes}"/>`;

            // Progress bar for simple mode
            if (simpleMode && task.progress !== undefined && task.progress > 0 && task.progress < 100) {
              const progressW = effectiveBarW * (task.progress / 100);
              svg += `<rect x="${barX}" y="${barY}" width="${progressW}" height="${barHeight}" rx="3" class="gantt-bar-progress"/>`;
            }

            // Critical span marker for simple mode (PRD overview)
            // Show red dashed line if actual span exceeds critical span by more than 10%
            if (simpleMode && task.criticalTimespanHours && task.criticalTimespanHours > 0 && actualTimespan > task.criticalTimespanHours * 1.10) {
              const criticalX = barX + (task.criticalTimespanHours * unitWidth);
              // Draw line extending slightly above and below the bar for visibility
              svg += `<line x1="${criticalX}" y1="${barY - 2}" x2="${criticalX}" y2="${barY + barHeight + 2}" stroke="#EF4444" stroke-width="2" stroke-dasharray="4 2"/>`;
            }
          }

          svg += `</g>`;
        });
      }

      svg += `</svg>`;
      container.innerHTML = svg;
    }

    // Escape HTML for SVG text content
    function escapeHtml(text) {
      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // Custom Gantt tooltip
    (function() {
      let tooltip = null;

      function createTooltip() {
        if (tooltip) return tooltip;
        tooltip = document.createElement('div');
        tooltip.className = 'gantt-tooltip';
        document.body.appendChild(tooltip);
        return tooltip;
      }

      function showTooltip(e, bar) {
        const tip = createTooltip();
        const name = bar.dataset.name || '';
        const epic = bar.dataset.epic || '';
        const startHour = parseFloat(bar.dataset.start) || 0;
        const endHour = parseFloat(bar.dataset.end) || 0;
        const durationRaw = parseFloat(bar.dataset.duration) || 0;
        const duration = Math.round(durationRaw * 10) / 10; // Round to 1 decimal
        const status = bar.dataset.status || '';
        const isCritical = bar.dataset.critical === '1';
        const blockedBy = bar.dataset.blockedBy ? bar.dataset.blockedBy.split(',').filter(s => s) : [];
        const blocks = bar.dataset.blocks ? bar.dataset.blocks.split(',').filter(s => s) : [];

        // Get startDate from container for date conversion
        const container = bar.closest('.sailing-gantt-target');
        const startDate = container?._startDate || new Date();

        // Convert hours to dates (date only, no time)
        const hoursToDate = (hours) => {
          const d = new Date(startDate);
          d.setHours(d.getHours() + hours);
          return d.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
        };

        const startDateStr = hoursToDate(startHour);
        const endDateStr = hoursToDate(endHour);

        // Check if simple mode (PRD overview) - use "Effort" instead of "Duration"
        const isSimpleMode = container?._simpleMode || false;
        const durationLabel = isSimpleMode ? 'Effort' : 'Duration';

        let html = `<div class="gantt-tooltip-title">${name}</div>`;
        if (epic) {
          html += `<div class="gantt-tooltip-row"><span class="gantt-tooltip-label">Epic:</span> <span class="gantt-tooltip-value">${epic}</span></div>`;
        }
        html += `<div class="gantt-tooltip-row"><span class="gantt-tooltip-label">Start:</span> <span class="gantt-tooltip-value">${startDateStr}</span> <span class="gantt-tooltip-label">End:</span> <span class="gantt-tooltip-value">${endDateStr}</span></div>`;
        html += `<div class="gantt-tooltip-row"><span class="gantt-tooltip-label">${durationLabel}:</span> <span class="gantt-tooltip-value">${duration}h</span> <span class="gantt-tooltip-label">Status:</span> <span class="gantt-tooltip-value">${status}</span></div>`;
        if (blockedBy.length > 0) {
          html += `<div class="gantt-tooltip-row"><span class="gantt-tooltip-label">Blocked by:</span> <span class="gantt-tooltip-value">${blockedBy.join(', ')}</span></div>`;
        }
        if (blocks.length > 0) {
          html += `<div class="gantt-tooltip-row"><span class="gantt-tooltip-label">Blocks:</span> <span class="gantt-tooltip-value">${blocks.join(', ')}</span></div>`;
        }
        if (isCritical) {
          html += `<div class="gantt-tooltip-critical">âš¡ Critical Path</div>`;
        }

        tip.innerHTML = html;
        tip.classList.add('visible');
        positionTooltip(e);
      }

      function positionTooltip(e) {
        if (!tooltip) return;
        const x = e.clientX + 12;
        const y = e.clientY + 12;
        const rect = tooltip.getBoundingClientRect();
        const maxX = window.innerWidth - rect.width - 8;
        const maxY = window.innerHeight - rect.height - 8;
        tooltip.style.left = Math.min(x, maxX) + 'px';
        tooltip.style.top = Math.min(y, maxY) + 'px';
      }

      function hideTooltip() {
        if (tooltip) tooltip.classList.remove('visible');
      }

      document.addEventListener('mouseover', (e) => {
        const bar = e.target.closest('.gantt-bar');
        if (bar) showTooltip(e, bar);
      });

      document.addEventListener('mouseout', (e) => {
        const bar = e.target.closest('.gantt-bar');
        if (bar) hideTooltip();
      });

      document.addEventListener('click', (e) => {
        const bar = e.target.closest('.gantt-bar');
        if (bar) hideTooltip();
      });

      document.addEventListener('mousemove', (e) => {
        const bar = e.target.closest('.gantt-bar');
        if (bar && tooltip && tooltip.classList.contains('visible')) {
          positionTooltip(e);
        }
      });
    })();

    // Apply title tooltips to DAG nodes
    function applyDagTooltips(container) {
      if (!window._dagTooltips) return;
      const tooltips = window._dagTooltips;
      for (const [nodeId, title] of Object.entries(tooltips)) {
        // Mermaid creates nodes with class .node and id containing the node name
        const nodes = container.querySelectorAll(`.node[id*="${nodeId}"], [id*="flowchart-${nodeId}"]`);
        // Format: "E001: Title of the epic"
        const tooltipText = `${nodeId.replace(/_/g, '-')}: ${title}`;
        nodes.forEach(node => {
          // Add <title> to the main group (SVG tooltip)
          if (!node.querySelector(':scope > title')) {
            const titleEl = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            titleEl.textContent = tooltipText;
            node.insertBefore(titleEl, node.firstChild);
          }
          // Add SVG title to shape elements
          const shape = node.querySelector('rect.label-container, rect.basic, polygon, circle, ellipse, path');
          if (shape && !shape.querySelector('title')) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            t.textContent = tooltipText;
            shape.insertBefore(t, shape.firstChild);
          }
          // Add HTML title attribute to foreignObject content (for label text)
          const foreignObject = node.querySelector('foreignObject');
          if (foreignObject) {
            foreignObject.setAttribute('title', tooltipText);
            // Also add to all HTML children inside foreignObject
            foreignObject.querySelectorAll('div, span').forEach(el => {
              el.setAttribute('title', tooltipText);
            });
          }
          // Also add SVG title to .label group
          const labelGroup = node.querySelector('g.label');
          if (labelGroup && !labelGroup.querySelector(':scope > title')) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'title');
            t.textContent = tooltipText;
            labelGroup.insertBefore(t, labelGroup.firstChild);
          }
          node.style.cursor = 'pointer';
        });
      }
    }

    // Add horizontal grid lines to Gantt charts
    function addGanttGridLines(container) {
      const svg = container.querySelector('svg');
      if (!svg) return;

      // Find all task bars to determine row positions
      const tasks = svg.querySelectorAll('.task, .taskText');
      if (tasks.length === 0) return;

      // Get the grid area dimensions
      const gridGroup = svg.querySelector('.grid');
      if (!gridGroup) return;

      const bbox = gridGroup.getBBox();
      const startX = bbox.x;
      const endX = bbox.x + bbox.width;

      // Create a group for horizontal lines
      const linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      linesGroup.setAttribute('class', 'gantt-row-lines');

      // Get unique Y positions from task bars
      const taskBars = svg.querySelectorAll('rect.task, rect.taskTextOutsideRight, rect.taskTextOutsideLeft');
      const yPositions = new Set();
      taskBars.forEach(bar => {
        const y = parseFloat(bar.getAttribute('y') || '0');
        const height = parseFloat(bar.getAttribute('height') || '25');
        yPositions.add(y + height + 3); // Line below each task
      });

      // Add horizontal lines
      yPositions.forEach(y => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', startX.toString());
        line.setAttribute('x2', endX.toString());
        line.setAttribute('y1', y.toString());
        line.setAttribute('y2', y.toString());
        line.setAttribute('stroke', 'var(--border, #374151)');
        line.setAttribute('stroke-width', '0.5');
        line.setAttribute('stroke-opacity', '0.4');
        linesGroup.appendChild(line);
      });

      // Insert lines before task bars
      const tasksGroup = svg.querySelector('.grid');
      if (tasksGroup) {
        tasksGroup.parentNode.insertBefore(linesGroup, tasksGroup.nextSibling);
      }
    }

    // Re-render diagrams after HTMX swaps
    document.body.addEventListener('htmx:afterSettle', (evt) => {
      // Only restore tab when swapping the detail panel
      if (evt.detail.target.id === 'detail') {
        restoreTab();
        renderMermaid();
        renderSailingGantt();
      } else {
        renderMermaid();
        renderSailingGantt();
      }
    });

    // Handle clicks on mermaid nodes (format: "type:id")
    window.nodeClick = function(typeAndId) {
      const [type, id] = typeAndId.split(':');
      const apiPath = type === 'prd' ? `/api/prd/${id}` : type === 'epic' ? `/api/epic/${id}` : `/api/task/${id}`;
      htmx.ajax('GET', apiPath, '#detail');
    };

    // Toggle tasks visibility in PRD schema
    function toggleTasks(checkbox) {
      const dagWithTasks = document.getElementById('dag-with-tasks');
      const dagWithoutTasks = document.getElementById('dag-without-tasks');
      if (checkbox.checked) {
        dagWithTasks.style.display = 'block';
        dagWithoutTasks.style.display = 'none';
      } else {
        dagWithTasks.style.display = 'none';
        dagWithoutTasks.style.display = 'block';
      }
      // Re-render mermaid for the visible container
      setTimeout(renderMermaid, 100);
    }
  </script>
</body>
</html>
